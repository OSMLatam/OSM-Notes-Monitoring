#!/usr/bin/env bash
#
# Vulnerability Scanning Script
# Scans the codebase and system for known vulnerabilities
#
# Version: 1.0.0
# Date: 2025-12-31
#

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly SCRIPT_DIR
PROJECT_ROOT="$(dirname "${SCRIPT_DIR}")"
readonly PROJECT_ROOT

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m'

# Counters
VULN_CRITICAL=0
VULN_HIGH=0
VULN_MEDIUM=0
VULN_LOW=0
VULN_INFO=0

# Output file
OUTPUT_FILE=""
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
readonly TIMESTAMP

##
# Print colored message
##
print_message() {
    local color="${1}"
    shift
    echo -e "${color}$*${NC}"
    if [[ -n "${OUTPUT_FILE:-}" ]]; then
        echo "$*" >> "${OUTPUT_FILE}"
    fi
}

##
# Record vulnerability
##
record_vuln() {
    local severity="${1}"
    local component="${2}"
    local description="${3}"
    local recommendation="${4:-}"
    
    case "${severity}" in
        CRITICAL)
            ((VULN_CRITICAL++))
            print_message "${RED}" "  [CRITICAL] ${component}: ${description}"
            ;;
        HIGH)
            ((VULN_HIGH++))
            print_message "${RED}" "  [HIGH] ${component}: ${description}"
            ;;
        MEDIUM)
            ((VULN_MEDIUM++))
            print_message "${YELLOW}" "  [MEDIUM] ${component}: ${description}"
            ;;
        LOW)
            ((VULN_LOW++))
            print_message "${YELLOW}" "  [LOW] ${component}: ${description}"
            ;;
        INFO)
            ((VULN_INFO++))
            print_message "${BLUE}" "  [INFO] ${component}: ${description}"
            ;;
    esac
    
    if [[ -n "${recommendation}" ]]; then
        print_message "${BLUE}" "    Recommendation: ${recommendation}"
    fi
    
    if [[ -n "${OUTPUT_FILE:-}" ]]; then
        {
            echo "  [${severity}] ${component}: ${description}"
            if [[ -n "${recommendation}" ]]; then
                echo "    Recommendation: ${recommendation}"
            fi
        } >> "${OUTPUT_FILE}"
    fi
}

##
# Check bash version for known vulnerabilities
##
check_bash_version() {
    print_message "${BLUE}" "Checking bash version..."
    
    local bash_version
    bash_version=$(bash --version 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
    
    if [[ -z "${bash_version}" ]]; then
        record_vuln "MEDIUM" "bash" "Unable to determine bash version" "Ensure bash is installed and accessible"
        return
    fi
    
    # Check for Shellshock (CVE-2014-6271, CVE-2014-6277, CVE-2014-6278, CVE-2014-7169)
    # Fixed in bash 4.3.27, 4.2.53, 4.1.17, 4.0.40
    local major minor patch
    IFS='.' read -r major minor patch <<< "${bash_version}"
    
    if [[ "${major}" -lt 4 ]] || \
       { [[ "${major}" -eq 4 ]] && [[ "${minor}" -lt 1 ]]; } || \
       { [[ "${major}" -eq 4 ]] && [[ "${minor}" -eq 1 ]] && [[ "${patch}" -lt 17 ]]; } || \
       { [[ "${major}" -eq 4 ]] && [[ "${minor}" -eq 2 ]] && [[ "${patch}" -lt 53 ]]; } || \
       { [[ "${major}" -eq 4 ]] && [[ "${minor}" -eq 3 ]] && [[ "${patch}" -lt 27 ]]; }; then
        record_vuln "CRITICAL" "bash" "Bash version ${bash_version} is vulnerable to Shellshock (CVE-2014-6271, etc.)" "Upgrade bash to version 4.3.27 or later"
    else
        print_message "${GREEN}" "  ✓ Bash version ${bash_version} appears safe"
    fi
    
    # Check for other known vulnerabilities
    # CVE-2019-9924 (bash 5.0 patch 11)
    if [[ "${major}" -eq 5 ]] && [[ "${minor}" -eq 0 ]] && [[ "${patch}" -lt 11 ]]; then
        record_vuln "HIGH" "bash" "Bash version ${bash_version} may be vulnerable to CVE-2019-9924" "Upgrade bash to version 5.0.11 or later"
    fi
}

##
# Check PostgreSQL version for known vulnerabilities
##
check_postgresql_version() {
    print_message "${BLUE}" "Checking PostgreSQL version..."
    
    if ! command -v psql > /dev/null 2>&1; then
        record_vuln "INFO" "PostgreSQL" "psql not found in PATH" "Install PostgreSQL client tools if using PostgreSQL"
        return
    fi
    
    local pg_version
    pg_version=$(psql --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+' | head -1 || echo "")
    
    if [[ -z "${pg_version}" ]]; then
        record_vuln "MEDIUM" "PostgreSQL" "Unable to determine PostgreSQL version" "Verify PostgreSQL installation"
        return
    fi
    
    local major minor
    IFS='.' read -r major minor <<< "${pg_version}"
    
    # Check for versions with known critical vulnerabilities
    # PostgreSQL 9.x and 10.x are EOL
    if [[ "${major}" -lt 11 ]]; then
        record_vuln "CRITICAL" "PostgreSQL" "PostgreSQL ${pg_version} is end-of-life and may have unpatched vulnerabilities" "Upgrade to PostgreSQL 11 or later"
    elif [[ "${major}" -eq 11 ]] && [[ "${minor}" -lt 20 ]]; then
        record_vuln "HIGH" "PostgreSQL" "PostgreSQL ${pg_version} is outdated" "Upgrade to PostgreSQL 11.20 or later"
    elif [[ "${major}" -eq 12 ]] && [[ "${minor}" -lt 15 ]]; then
        record_vuln "HIGH" "PostgreSQL" "PostgreSQL ${pg_version} is outdated" "Upgrade to PostgreSQL 12.15 or later"
    elif [[ "${major}" -eq 13 ]] && [[ "${minor}" -lt 11 ]]; then
        record_vuln "HIGH" "PostgreSQL" "PostgreSQL ${pg_version} is outdated" "Upgrade to PostgreSQL 13.11 or later"
    elif [[ "${major}" -eq 14 ]] && [[ "${minor}" -lt 8 ]]; then
        record_vuln "MEDIUM" "PostgreSQL" "PostgreSQL ${pg_version} may have security updates available" "Consider upgrading to PostgreSQL 14.8 or later"
    else
        print_message "${GREEN}" "  ✓ PostgreSQL version ${pg_version} appears current"
    fi
}

##
# Check curl version for known vulnerabilities
##
check_curl_version() {
    print_message "${BLUE}" "Checking curl version..."
    
    if ! command -v curl > /dev/null 2>&1; then
        record_vuln "INFO" "curl" "curl not found in PATH" "Install curl if using HTTP health checks"
        return
    fi
    
    local curl_version
    curl_version=$(curl --version 2>/dev/null | head -1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1 || echo "")
    
    if [[ -z "${curl_version}" ]]; then
        record_vuln "MEDIUM" "curl" "Unable to determine curl version" "Verify curl installation"
        return
    fi
    
    local major minor patch
    IFS='.' read -r major minor patch <<< "${curl_version}"
    
    # Check for versions with known critical vulnerabilities
    # CVE-2021-22946 (curl 7.78.0)
    if [[ "${major}" -lt 7 ]] || \
       { [[ "${major}" -eq 7 ]] && [[ "${minor}" -lt 78 ]]; } || \
       { [[ "${major}" -eq 7 ]] && [[ "${minor}" -eq 78 ]] && [[ "${patch}" -lt 1 ]]; }; then
        record_vuln "HIGH" "curl" "curl version ${curl_version} may be vulnerable to CVE-2021-22946" "Upgrade curl to version 7.78.1 or later"
    else
        print_message "${GREEN}" "  ✓ curl version ${curl_version} appears current"
    fi
}

##
# Check for hardcoded secrets
##
check_hardcoded_secrets() {
    print_message "${BLUE}" "Scanning for hardcoded secrets..."
    
    local found_secrets=0
    
    # Patterns to search for
    local patterns=(
        "password\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "PASSWORD\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "secret\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "SECRET\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "api_key\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "API_KEY\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "token\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
        "TOKEN\\s*=\\s*['\\\"][^'\\\"]+['\\\"]"
    )
    
    while IFS= read -r file; do
        # Skip binary files and common non-secret files
        if file "${file}" 2>/dev/null | grep -qE "(binary|executable|archive)"; then
            continue
        fi
        
        # Skip .git directory
        if [[ "${file}" == *".git"* ]]; then
            continue
        fi
        
        for pattern in "${patterns[@]}"; do
            if grep -nE "${pattern}" "${file}" 2>/dev/null | grep -vE "(example|test|mock|dummy|placeholder|TODO|FIXME)" > /dev/null; then
                local line
                line=$(grep -nE "${pattern}" "${file}" 2>/dev/null | grep -vE "(example|test|mock|dummy|placeholder|TODO|FIXME)" | head -1 || echo "")
                if [[ -n "${line}" ]]; then
                    record_vuln "CRITICAL" "${file}" "Potential hardcoded secret found: ${line}" "Move secrets to environment variables or secure configuration files"
                    ((found_secrets++))
                    break
                fi
            fi
        done
    done < <(find "${PROJECT_ROOT}" -type f \( -name "*.sh" -o -name "*.bash" -o -name "*.conf" -o -name "*.config" -o -name "*.sql" \) ! -path "*/\.git/*" ! -path "*/node_modules/*" ! -path "*/tmp/*" ! -path "*/tests/tmp/*" 2>/dev/null)
    
    if [[ ${found_secrets} -eq 0 ]]; then
        print_message "${GREEN}" "  ✓ No obvious hardcoded secrets found"
    fi
}

##
# Check file permissions
##
check_file_permissions() {
    print_message "${BLUE}" "Checking file permissions..."
    
    local insecure_files=0
    
    # Check for world-writable files
    while IFS= read -r file; do
        if [[ -f "${file}" ]] && [[ -w "${file}" ]] && [[ -w "${file}" ]]; then
            local perms
            perms=$(stat -c "%a" "${file}" 2>/dev/null || stat -f "%OLp" "${file}" 2>/dev/null || echo "")
            if [[ "${perms}" == *"2"* ]] || [[ "${perms}" == *"6"* ]] || [[ "${perms}" == *"7"* ]]; then
                record_vuln "HIGH" "${file}" "File is world-writable (permissions: ${perms})" "Restrict file permissions: chmod 640 ${file}"
                ((insecure_files++))
            fi
        fi
    done < <(find "${PROJECT_ROOT}" -type f ! -path "*/\.git/*" ! -path "*/tmp/*" ! -path "*/tests/tmp/*" 2>/dev/null)
    
    # Check for scripts without execute permission but referenced as executable
    while IFS= read -r file; do
        if [[ -f "${file}" ]] && ! [[ -x "${file}" ]]; then
            # Check if file is referenced as executable in other scripts
            if grep -r "\"${file}\"" "${PROJECT_ROOT}" --include="*.sh" 2>/dev/null | grep -vE "(test|example)" > /dev/null; then
                record_vuln "LOW" "${file}" "Script referenced but missing execute permission" "Add execute permission: chmod +x ${file}"
            fi
        fi
    done < <(find "${PROJECT_ROOT}/bin" -type f -name "*.sh" 2>/dev/null)
    
    if [[ ${insecure_files} -eq 0 ]]; then
        print_message "${GREEN}" "  ✓ File permissions appear secure"
    fi
}

##
# Check for insecure configurations
##
check_insecure_configs() {
    print_message "${BLUE}" "Checking for insecure configurations..."
    
    local issues=0
    
    # Check for SQL injection patterns
    while IFS= read -r file; do
        if grep -nE "\$\{.*\}.*\+.*['\\\"]" "${file}" 2>/dev/null | grep -vE "(test|example|comment)" > /dev/null; then
            local line
            line=$(grep -nE "\$\{.*\}.*\+.*['\\\"]" "${file}" 2>/dev/null | grep -vE "(test|example|comment)" | head -1 || echo "")
            if [[ -n "${line}" ]]; then
                record_vuln "MEDIUM" "${file}" "Potential SQL injection risk: ${line}" "Use parameterized queries or proper escaping"
                ((issues++))
            fi
        fi
    done < <(find "${PROJECT_ROOT}/bin" -type f -name "*.sh" 2>/dev/null)
    
    # Check for command injection patterns
    while IFS= read -r file; do
        if grep -nE "\$\(.*\$\{" "${file}" 2>/dev/null | grep -vE "(test|example|comment)" > /dev/null; then
            local line
            line=$(grep -nE "\$\(.*\$\{" "${file}" 2>/dev/null | grep -vE "(test|example|comment)" | head -1 || echo "")
            if [[ -n "${line}" ]]; then
                record_vuln "MEDIUM" "${file}" "Potential command injection risk: ${line}" "Validate and sanitize user input before execution"
                ((issues++))
            fi
        fi
    done < <(find "${PROJECT_ROOT}/bin" -type f -name "*.sh" 2>/dev/null)
    
    # Check for use of eval
    while IFS= read -r file; do
        if grep -nE "\\beval\\b" "${file}" 2>/dev/null | grep -vE "(test|example|comment|shellcheck)" > /dev/null; then
            local line
            line=$(grep -nE "\\beval\\b" "${file}" 2>/dev/null | grep -vE "(test|example|comment|shellcheck)" | head -1 || echo "")
            if [[ -n "${line}" ]]; then
                record_vuln "HIGH" "${file}" "Use of eval detected: ${line}" "Avoid eval when possible, use safer alternatives"
                ((issues++))
            fi
        fi
    done < <(find "${PROJECT_ROOT}/bin" -type f -name "*.sh" 2>/dev/null)
    
    if [[ ${issues} -eq 0 ]]; then
        print_message "${GREEN}" "  ✓ No obvious insecure configurations found"
    fi
}

##
# Check for outdated packages (if apt/yum available)
##
check_package_updates() {
    print_message "${BLUE}" "Checking for available package updates..."
    
    if command -v apt-get > /dev/null 2>&1; then
        if sudo -n true 2>/dev/null; then
            local updates
            updates=$(apt-get -s upgrade 2>/dev/null | grep -cE "^Inst" || echo "0")
            if [[ "${updates}" -gt 0 ]]; then
                record_vuln "MEDIUM" "System Packages" "${updates} package updates available via apt-get" "Run: sudo apt-get update && sudo apt-get upgrade"
            else
                print_message "${GREEN}" "  ✓ System packages appear up to date"
            fi
        else
            print_message "${YELLOW}" "  ⚠ Skipping package update check (requires sudo)"
        fi
    elif command -v yum > /dev/null 2>&1; then
        if sudo -n true 2>/dev/null; then
            local updates
            updates=$(yum check-update --quiet 2>/dev/null | grep -cE "^[a-zA-Z]" || echo "0")
            if [[ "${updates}" -gt 0 ]]; then
                record_vuln "MEDIUM" "System Packages" "${updates} package updates available via yum" "Run: sudo yum update"
            else
                print_message "${GREEN}" "  ✓ System packages appear up to date"
            fi
        else
            print_message "${YELLOW}" "  ⚠ Skipping package update check (requires sudo)"
        fi
    else
        print_message "${YELLOW}" "  ⚠ Package manager not found (apt-get/yum)"
    fi
}

##
# Generate summary report
##
generate_summary() {
    echo ""
    print_message "${BLUE}" "=========================================="
    print_message "${GREEN}" "Vulnerability Scan Summary"
    print_message "${BLUE}" "=========================================="
    echo ""
    
    print_message "${RED}" "Critical: ${VULN_CRITICAL}"
    print_message "${RED}" "High: ${VULN_HIGH}"
    print_message "${YELLOW}" "Medium: ${VULN_MEDIUM}"
    print_message "${YELLOW}" "Low: ${VULN_LOW}"
    print_message "${BLUE}" "Info: ${VULN_INFO}"
    echo ""
    
    local total=$((VULN_CRITICAL + VULN_HIGH + VULN_MEDIUM + VULN_LOW))
    
    if [[ ${total} -eq 0 ]]; then
        print_message "${GREEN}" "✓ No vulnerabilities found!"
    elif [[ ${VULN_CRITICAL} -gt 0 ]] || [[ ${VULN_HIGH} -gt 0 ]]; then
        print_message "${RED}" "✗ Critical or high-severity vulnerabilities found. Immediate action required."
    else
        print_message "${YELLOW}" "⚠ Some vulnerabilities found. Review and address as needed."
    fi
    
    if [[ -n "${OUTPUT_FILE:-}" ]]; then
        print_message "${BLUE}" "Full report saved to: ${OUTPUT_FILE}"
    fi
}

##
# Main
##
main() {
    local output_dir="${PROJECT_ROOT}/reports"
    mkdir -p "${output_dir}"
    OUTPUT_FILE="${output_dir}/vulnerability_scan_${TIMESTAMP}.txt"
    
    print_message "${GREEN}" "Vulnerability Scan for OSM-Notes-Monitoring"
    print_message "${BLUE}" "Started at: $(date)"
    echo ""
    
    {
        echo "Vulnerability Scan Report"
        echo "Generated: $(date)"
        echo "Project: OSM-Notes-Monitoring"
        echo ""
    } > "${OUTPUT_FILE}"
    
    # Run checks
    check_bash_version
    check_postgresql_version
    check_curl_version
    check_hardcoded_secrets
    check_file_permissions
    check_insecure_configs
    check_package_updates
    
    # Generate summary
    generate_summary
    
    # Exit with appropriate code
    local total_critical_high=$((VULN_CRITICAL + VULN_HIGH))
    if [[ ${total_critical_high} -gt 0 ]]; then
        exit 1
    else
        exit 0
    fi
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
